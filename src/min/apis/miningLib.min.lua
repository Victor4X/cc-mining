require(settings.get("ghu.base").."core/apis/ghu")require("qol")function sortReqs()missing={}req="enderchests:ender_chest"res=moveByName(req,16)if not res then missing[req]=true end;req="fluxnetworks:flux_point"res=moveByName(req,15)if not res then missing[req]=true end;req="peripherals:induction_charger"res=moveByName(req,14)if not res then missing[req]=true;print("Debug, ln29")end;if setLen(missing)>0 then return false,missing end;return true end;function mineRing(a,b,c)b=b or noop;c=c or{}t.turnRight()for d=1,a do if b(unpack(c))then return true end;t.dig()t.forward()end;t.turnLeft()for d=1,a*2 do if b(unpack(c))then return true end;t.digDown()t.down()end;t.turnLeft()for d=1,a*2 do if b(unpack(c))then return true end;t.dig()t.forward()end;t.turnRight()for d=1,a*2 do if b(unpack(c))then return true end;t.digUp()t.up()end;t.turnRight()for d=1,a do if b(unpack(c))then return true end;t.dig()t.forward()end;t.turnLeft()end;function mineWall(a,b,c)b=b or noop;c=c or{}for e=a,1,-1 do if mineRing(e,b,c)then return true end;t.digDown()t.down()end;if b(unpack(c))then return true end;goUp(a*2-1)end;function mineAdjByName(f)if type(f)=="string"then f={name=true}end;res,block=t.inspectUp()if res then if f[block["name"]]then t.select(setLen(f))t.drop()t.digUp()f[block["name"]]=nil;if setLen(f)==0 then return true end end end;res,block=t.inspectDown()if res then if f[block["name"]]then t.select(setLen(f))t.drop()t.digDown()f[block["name"]]=nil;if setLen(f)==0 then return true end end end;for turns=0,3 do res,block=t.inspect()if res then if f[block["name"]]then t.select(setLen(f))t.drop()t.dig()turnL(turns)f[block["name"]]=nil;if setLen(f)==0 then return true end end end;t.turnRight()end;return false end;function mineByName(f,a,g)mABN=mineAdjByName;g=g or false;dir=0;relative=0;if not g then print("Running mineByName non-destructively is currently not implemented")return false end;if a==0 then return false end;if mineByName(f,a-1,g)then return true end;for d=1,a do if mABN(f)then return true end;t.dig()t.forward()end;if mABN(f)then return true end;t.digUp()t.up()if mineWall(a,mABN,{f})then return true end;turnR(2)for d=1,a*2-1 do t.dig()t.forward()if mineRing(a,mABN,{f})then return true end end;t.dig()t.forward()if mineWall(a,mABN,{f})then return true end;turnR(2)return false end;function dumpInv()turns=turnX()if turns>-1 then t.select(16)t.place()for d=1,13 do t.select(d)t.drop()end;t.select(16)t.dig()t.select(1)turnL(turns)return true end;return false end;function refuel()t.select(14)t.dig()t.forward()t.digDown()t.placeDown()t.back()t.digDown()t.select(15)t.placeDown()while t.getFuelLevel()<t.getFuelLimit()do sleep(0.2)end;t.digDown()t.select(14)t.drop()t.forward()t.digDown()t.back()return true end
